<!doctype html>
<html>
<title>About Invisible Ink</title>
<style>
body {
  font-family: 'Courier New', monospace;
  margin: 50px;
}
</style>

<span style="white-space: pre-wrap;">
WHAT IS INVISIBLE INK?

Invisible Ink is a web app and original concept that I came up with. You upload an image, then upload any file of your choosing (it can be any file type). The program will subtly change the pixels of your image to encode the data in your file.

Then, anyone can scan the image by uploading it to the program, and the program will be able to decode the file hidden inside. Then the user can download it.

It's easy to use, and it's a fun little piece of computer "magic".



WHO ARE YOU?

I'm Ikebot. I do lots of creative coding projects like this.
</span>
<a href="http://ikebot108.weebly.com/" target="_blank">See my website</a>

<span style="white-space: pre-wrap;">



HOW DOES INVISIBLE INK WORK?

The program takes advantage of modular arithmetic and writing numbers in different bases (radices). If you're unfamiliar with these concepts, I'd recommend reading about them first. They are pretty simple and they have very interesting applications in cryptography and computer science! Here is a simplified version of how my program works:

To create an encoded image, the program first takes the file you want to encode and converts it into a string of hexadecimal data (e.g. ff890aa27ec...) kind of like how all files are a bunch of "zeros" and "ones" under the hood (binary data). Then, the program treats that data like one very large number, and rewrites the number in a different base (or radix) of the user's choosing (which I've described in the UI as the "pixel color variance level"). The resulting number (let's call it the "data number") may have more or fewer digits than the original hexadecimal data. You'll see why this user-selected base is important in a minute.

Then, the program starts editing the pixels of your image from left to right, top to bottom (the same order you would read a book). As you may know, every pixel in an image has a red, green, and blue brightness value (between 0 and 255). The program can change the red value to match the first digit of the "data number", then the green value to match the second digit, then the blue value to match the third digit, and then it moves on to the next pixel to encode more digits. This means that every pixel of the image encodes three digits of the "data number", so if the data number is three hundred digits long, the program only needs to modify one hundred pixels of your image (the rest of the pixels will be encoded with a value of zero, so the program knows to ignore them).

But how does the program do this while ensuring that the pixels still look close to their original color? This is where modular arithmetic comes in. When the program changes a pixel's color channel, it "rounds" the data to a multiple of the user-selected base, and then adds the desired value on top of that.

What does that mean? For example, imagine the program needs to encode the number 7 into a pixel's red value. The original red value is 44, and the program wants to keep the new value close to that. The user has selected a base of 10, so the program rounds 44 to the nearest multiple of 10 to get 40, and then adds the *actual* desired number, 7, on top of that to get 47, which is pretty close to the original number.

The higher the user's selected base is, the more extreme this rounding will be, so colors will be further from the original than they would be with a smaller base. However, a higher base means the program needs to modify fewer pixels, whereas if the base is very small (like 3 or 4) it will need to encode a lot more pixels, and it may have to enlarge your image to accomodate this. The image will also take longer to encode and decode. That's why I have left it up to the user to weigh these factors themselves to decide what base to use.

To decode an image, the program reads the pixels left to right, top to bottom, just like before, and scans the red, green, and blue values of each pixel to find the digits of the hidden "data number". When it notices the pixel with a red value of 44, it will take away the biggest multiple of ten that it can (40) and it will look at the remainder (4) to get the encoded digit. That's what the modulus (%) operator does. You can also think of it as the remainder when you divide 44 by 10. After it's done scanning all the pixels, it will take the resulting "data number" and convert it into hexadecimal (base 16). Then, it will turn the resulting hexadecimal code into a file that you can download!




= = = = = = = = = = = = = = = = =

A MORE DETAILED EXPLANATION:

The above explanation has some inaccuracies to keep it simple. Here is some pseudo-code to describe what the program actually does in detail. Hopefully it's specific enough that a coder could recreate the program themselves by following this guide:

TO ENCODE AN IMAGE:

1. The first pixel (the upper-left corner) of the original image is actually reserved for telling the program what base the image is encoded in (the user-selected base). The user must select a base between 3 and 36 (for reasons I will explain later), so the base will be no bigger than 36. The program takes advantage of this. It rounds the first pixel's red value to the nearest multiple of 36, and then adds to that the user-selected base. That way, the decoder can know what base the user selected by taking the red value modulus 36. The blue and green values of the first pixel are unused, so they stay the same as in the original image.

2. The second and third pixels actually store the file extension of the file that's encoded (like .txt or .pdf). This is because you actually can't know what file type a file is from the hex data alone (a human could look at the hex data and maybe make an educated guess at the file type, but it's much easier just to sacrifice two pixels to store this info). The RGB values of the second pixel store the first three characters of the extension name, and the RGB values of the third pixel store the next three characters (if there are any). For this reason, files with an extension that is longer than 6 characters are not allowed. The program stores this data by designating each letter of the alphabet (and each of the ten number symbols) to a value between 0 and 35:
a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9
0 1 2 3 4 5 6 7 8 9 ... etc ...                                    ...35

Then, as with pixel #1 of the image, the RGB values of pixels 2 and 3 are rounded to the nearest multiple of 36, and then the numerical values of the characters in the file extension are added to this. The number zero (with a designated value of 26) is a placeholder for if there are no more characters in the file extension (if the extension is less than six characters long, which it usually will be). For this reason, the user isn't allowed to use files that have an actual 0 in the extension, since the program would ignore them.

Yes, I am assuming the user has uploaded an image with at least three pixels in it. You are by all means welcome to crash the program by uploading an image with less than three pixels.

3. The file to be encoded is converted into a string of hexadecimal digits. Then, this hexadecimal data is treated like one big number. The data is actually converted into a base that's one less than what the user selected, (which is why the minimum option is 3) and I will explain why in a moment. Again, let's call this new number the "data number".

In Javascript, this conversion is easy to do with the BigInt() data type and it doesn't take awfully long to compute, even for fairly large files. The reason we warn the user about encoding files larger than 100 KB is because the file size exponentially slows down the decoding process, unless the user-selected base is 17 (see "decoding" below).

4. The program checks to see if the image contains enough pixels for the number of digits in the data number (there must be at least one pixel for every three digits). If not, the program resizes the image to fit enough pixels according to this formula:

ow = original width
oh = original height
dp = desired number of pixels = number of digits in the "data number" divided by three, rounded up (might as well round up).
nw = new width
nh = new height
nw = sqrt( ( ow * dp ) / oh ) , rounded up
nh = nw/(ow/oh)

We don't need to worry about the image having *too many* pixels.

4. The rest of the pixels (that encode the actual data) are edited in order from left to right, top to bottom. Each RGB color value is rounded to the nearest multiple of the user-selected base. To this, we add one plus the value of the corresponding digit of the "data number" (the digit is first converted into base-ten).* The reason for the extra "one" is to ensure that none of the pixels are encoded with a value of zero, because we will use the value zero to represent no data. This is why, if the user has selected base 3, the data will actually be encoded in base 2; because we need that extra digit to represent "no data".

5. As mentioned, any extra pixels are encoded with a value of zero to represent no data. This is achieved by rounding each color value to the nearest multiple of the user-selected base (and adding nothing to it, hence zero is encoded).

*Extra detail about the new color value: by following these steps, the program may sometimes choose a new color value that's greater than 255. This needs to be prevented since color values max out at 255. To prevent this, the program simply subtracts the calculated color value by the user-selected base.


TO DECODE AN IMAGE:

1. The program takes the red value of the first pixel (the one in the upper-left corner) and takes this value mod 36 to know the user-selected base. If it gets a value of zero, it assumes that the user-selected base is 36.

2. The RGB values of the second and third pixels are taken mod 36. Then, the program converts each resulting value to a character according to the table mentioned in step 2 of encoding. That's how it knows the extension of the file. Any zeros are discarded. The original file's name is not recorded, so the program will just name the file "myFile" when the user downloads it.

3. The rest of the pixels are scanned from left to right, top to bottom. Each color value is taken mod the user-selected base, and then subtracted by one (to undo the "extra one" mentioned in step 4 of encoding) to get the corresponding digit of the "data number" (it is first converted from base 10 back into the user-selected base). The program ignores any color values that become 0 when they are taken mod the user-selected base.

4. Once all of the digits of the data number are collected, the data number is converted into base ten. To do this, my program uses a function called parseBigInt() that was taken from StackOverflow. This function gets exponentially slower the larger the data number is, and it takes far too long to decode any file that's larger than 100 KB. However, the program only needs to use parseBigInt() so that it can then convert the number into base-16 (hexadecimal). So if the data is already encoded in base 16, then the program can skip this step entirely, which is why the user is encouraged to choose base 17 when encoding a file larger than 100 KB; if they do, the data will *actually* be encoded in base 16.

5. After the digits are converted into base 16, this hexadecimal data can be converted into a file by the program, and then downloaded. To do this, I used another function that I stole from stackOverflow called hexToFile(). The only reason we read and record the extension of the file at all is so that, upon download, the file can be automatically named with the correct extension.

</span>

</body>
</html>
